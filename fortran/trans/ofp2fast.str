module ofp2fast

imports
   libstratego-lib
   Main
   FAST
   ofp-simplify

signature
  constructors

  // These extra constructors are not part of FAST but used in intermediate stages
  //
  SpecPart : ListStarOfDecl -> SpecPart
  ExecPart : ListStarOfStmt -> ExecPart
  FuncPart : ListStarOfDecl -> FuncPart

  // Ambiguities
  amb : list -> choice

  OfpBlockDoConstruct : begin_stmt * block * end_stmt -> OfpBlockDoConstruct
  xFunctionStmt       : label * name * args * prefix * result * binding -> xFunctionStmt

  Comment   : A -> B            /* comments are put in annotations */
  OfpString : A -> B            /* node for a string literal */
  ERROR     : A -> B            /* error reporting for a node */

  comment : A -> B              /* need a better way to remove comments */

  COLON     :      COLON

strategies //=================START OF STRATEGIES============================

  main = io-wrap(ofp2fast)

  ofp2fast =
      ofp-simplify
//    ; outermost(to-comment)
//    ; outermost(from-comment)
    ; innermost(ofp-to-ast)
    ; topdown(try(fast-fixup-spec-part))
    ; topdown(try(fast-fixup-do-constructs))
    ; topdown(try(fast-cleanup))

transfer-type(|type) =
     ?Var(name,unknown-type(),init)
  ;  !Var(name,type,init)

// TODO - try to remove usage of Some()
//ofp-add-some = ?None() < id + !Some(<id>)
  ofp-add-some = id

//  ofp-name       = is-string < !OfpName (<id>)       + !None()
//  ofp-name-some  = is-string < !Some(OfpName (<id>)) + !None()
//  ofp-name-fail  = is-string ; !OfpName (<id>)

//  ofp-label      = is-string < !Label(<id>) + !None()

//  ofp-spec       = is-string < !Some(OfpGenericSpec(Name(<id>))) + !None()

  ofp-char-select = id
  ofp-kind = id
//ofp-args = !OfpArgList(<id>)

//ofp-prefix = is-list < !OfpPrefix(<id>) + !OfpPrefix([])
//ofp-suffix = ?no-language-binding() < !OfpSuffix([]) + !OfpSuffix(<id>)

//  ofp-var-def = is-string < !VarDef(Name(<id>)) + !ERROR(<id>)
//  ofp-var-ref = is-string < !VarRef(Name(<id>)) + id

rules //========================START OF RULES===============================

  to-comment:    eos(_)       -> comment("\n")
  from-comment:  comment(str) -> eos(str)

  fast-cleanup:  SpecPart(lst) -> lst
  fast-cleanup:  ExecPart(lst) -> lst
  fast-cleanup:  FuncPart(lst) -> lst

  fast-cleanup:    xFunctionStmt(label,prefix,name,args,result,binding)
                ->  FunctionStmt(label,prefix,name,args,result,binding)


  ofp-extract-name:  SubmoduleStmt    (_,_,name,_)          -> name
  ofp-extract-name:  MpSubprogramStmt (_,name,_)            -> name

  ofp-extract-result:   no-suffix()                         -> no-result()
  ofp-extract-result:   Suffix(_,no-result())               -> no-result()
  ofp-extract-result:   Suffix(no-result(),_)               -> no-result()
  ofp-extract-result:   Suffix(Result(name),_)              -> Result(name)
  ofp-extract-result:   Suffix(_,Result(name))              -> Result(name)

  ofp-extract-binding:  no-suffix()                         -> no-language-binding()
  ofp-extract-binding:  Suffix(_,no-language-binding())     -> no-language-binding()
  ofp-extract-binding:  Suffix(no-language-binding(),_)     -> no-language-binding()
  ofp-extract-binding:  Suffix(_,LanguageBinding(name))     -> LanguageBinding(name)
  ofp-extract-binding:  Suffix(LanguageBinding(name),_)     -> LanguageBinding(name)

  ofp-extract-subprograms:  no-subprogram-part()            -> FuncPart([])
  ofp-extract-subprograms:  SubprogramPart(_,subprograms)   -> FuncPart(subprograms)

  ofp-extract-contains:  no-subprogram-part()               -> None()
  ofp-extract-contains:  SubprogramPart(contains,_)         -> contains

  ofp-fixup-scope:
      Scope(spec,exec,funcs) -> Scope(spec,exec,<ofp-extract-subprograms>funcs)

// The fast-fixup-spec-part strategy transfers statements in the execution-part to the
// specification-part.  The statements transferred are in the execution-part because
// of ambiguities in the grammar related to format, entry, and data statements being
// in both the declaration-construct and the execution-part-construct.
//

fast-fixup-spec-part =
{spec_list
  :  ?Scope(SpecPart(slist),ExecPart(elist),funcs)
  ;  <concat>[slist,<take-while(is-specification-part)> elist] => spec_list
  ;  <drop-while(is-specification-part)> elist
  ;  !Scope(SpecPart(spec_list),ExecPart(<id>),funcs)
}

// TODO - add derived-type-def, enum-def, interface-block
//        procedure-declaration-stmt, stmt-function-stmt, access-stmt, allocatable-stmt
//        bind-stmt, comdimension-stmt, common-stmt
// Probably also entry-stmt, data-stmt, and format-stmt that precede any truly executable
// statements.
//
is-specification-part =
     ?ImplicitStmt(_,_)
 +>  ?ParameterStmt(_,_,_)
 +>  ?TypeDeclarationStmt(_,_,_,_,_)

// Call the recursive strategy fast-fixup-do-construct (directly below) to build multiple
// OfpBlockDoConstructs from a series of do statements.
//
fast-fixup-do-constructs =
{exec_list
  :  ?Scope(spec_part,ExecPart(elist),funcs)
  ;  <fast-fixup-do-construct> ([],elist)
  ;  ?(before,rest)
  ;  !Scope(spec_part,ExecPart(<concat>[before,rest]),funcs)
}

// This strategy uses recursion to build multiple OfpBlockDoConstructs from
// a series of do statements.  Each pass attempts to build one OfpBlockDoConstruct.
// It exits the recursive loop when the try(<fast-fixup-do-construct>) recursion
// fails.
//
fast-fixup-do-construct =
     ?(exec_list,remaining)
  ;  <split-fetch-keep(match-begin-block-do)> remaining
  ;  ?(before,begin_do,after)
  ;  <split-fetch-keep(match-end-do)> after
  ;  ?(block,end_do,rest)
  ;  !OfpBlockDoConstruct(begin_do,block,end_do)
  ;  !(<concat>[exec_list,before,[<id>]], rest)
  ;  try(<fast-fixup-do-construct> <id>)


match-begin-block-do =
     ?NonlabelDoStmt(label,name,control,eos)

match-end-do =
     ?EndDoStmt(label,name,eos)


//R201
  ofp-to-ast:  Program(no-comments(), ProgramUnits) -> Program(ProgramUnits)
  ofp-to-ast:  Program(str,           ProgramUnits) -> Program(ProgramUnits) {Comment(str)}

//R204
  ofp-to-ast:
    SpecificationPart(l1)                       -> SpecPart(l1)

  ofp-to-ast:
    InitialSpecPart(l1)                         -> SpecPart(l1)

//R208
  ofp-to-ast:  SpecAndExecPart(stmts)           -> ExecPart(stmts)

//R404
ofp-to-ast:  IntrinsicType(type)                -> type

ofp-to-ast:  INTEGER(no-kind())                 -> INTEGER()
ofp-to-ast:  REAL(no-kind())                    -> REAL()
ofp-to-ast:  COMPLEX(no-kind())                 -> COMPLEX()
ofp-to-ast:  CHARACTER(no-char-selector)        -> CHARACTER()
ofp-to-ast:  LOGICAL(no-kind())                 -> LOGICAL()

//R405
ofp-to-ast:  KindSelector(k)                    -> Kind(k)
ofp-to-ast:  KindSelector_STAR(k)               -> Kind(k)

//R408
ofp-to-ast:
  IntLiteralConstant(val,no-kind-param())       -> IntVal(val)
ofp-to-ast:
  IntLiteralConstant(val,kind)                  -> IntVal(val,Kind(kind))

//R413
ofp-to-ast:
  RealLiteralConstant(val,no-kind-param())      -> RealVal(val)
ofp-to-ast:
  RealLiteralConstant(val,kind)                 -> RealVal(val,Kind(kind))

//R501
  ofp-to-ast:    TypeDeclarationStmt(label,type,attrs,vars,eos("\n"))
              -> TypeDeclarationStmt(label,type,attrs,<map(transfer-type(|type))>vars)
  ofp-to-ast:    TypeDeclarationStmt(label,type,attrs,vars,eos(str))
              -> TypeDeclarationStmt(label,type,attrs,<map(transfer-type(|type))>vars) {Comment(str)}

//R503
  ofp-to-ast:  EntityDecl(name,[],[],no-char-length(),init)
                                                -> Var(name,unknown-type(),init)

//R510
//  ofp-to-ast:  DeferredCoshape()                -> DimSpec(no-lower-bound(), COLON())
  ofp-to-ast:  DeferredCoshape()                -> COLON()

//R511
  ofp-to-ast:  ExplicitCoshape(lower,upper)     -> Range(lower,upper)

//R516
  ofp-to-ast:  ExplicitShape(lower,upper)       -> Range(lower,upper)
//  ofp-to-ast:  ExplicitShapeSpecList(list)      -> OfpExplicitShape(list)

//R519
//  ofp-to-ast:  AssumedShapeSpec(AssumedOrDeferredShapeSpec()) -> DimSpec(None(),":")
//  ofp-to-ast:  AssumedShape(lower)              -> DimSpec(lower,":")

//R520
//  ofp-to-ast:  DeferredShape()                  -> DimSpec(no-lower-bound(), COLON())
  ofp-to-ast:  DeferredShape()                  -> COLON()

//R521
//  ofp-to-ast:  AssumedSizeSpec(OfpExplicitShape(list), lower)
//                            -> OfpAssumedSize(<concat>[list, [DimSpec(lower,"*")]])
//  ofp-to-ast:  AssumedSizeSpec(OfpExplicitShape(list))
//                            -> OfpAssumedSize(<concat>[list, [DimSpec(None(),"*")]])

//R522
  ofp-to-ast:  ImpliedShapeSpecList(spec,list)    -> OfpImpliedShape(<concat>[[spec],list])

//R522a
//  ofp-to-ast:  AssumedRankSpec()                  -> OfpAssumedRank([DimSpec(None(),<ofp-add-some>"..")])

//R523
//  ofp-to-ast:  IN()                    -> OfpIntent(IN())
//  ofp-to-ast:  OUT()                   -> OfpIntent(OUT())
//  ofp-to-ast:  INOUT()                 -> OfpIntent(INOUT())

// assumed-size-spec and implied-shape-spec are ambiguous with only rank 1 array declarations
//    - The following four rules remove the ambiguity by choosing assumed-size over
//      implied-shape arrays. If there is an initializer then likely it really is implied-shape.
//
//  ofp-to-ast:  AssumedOrImpliedSpec()
//                            -> OfpAssumedSize([DimSpec(None(),"*")])
//  ofp-to-ast:  AssumedOrImpliedSpec(lower)
//                            -> OfpAssumedSize([DimSpec(lower,"*")])

  rm-assumed-size: OfpAssumedSize([l]) -> l

  ofp-to-ast:  OfpImpliedShape(l1) -> OfpImpliedShape( <map(rm-assumed-size)>l1 )

// Operators...

//R560 - TODO: implicit-spec-list
  ofp-to-ast:  ImplicitNoneStmt(label,eos("\n")) -> ImplicitStmt(label,[])
  ofp-to-ast:  ImplicitNoneStmt(label,eos(str) ) -> ImplicitStmt(label,[]) {Comment(str)}

//R703
//  ofp-to-ast:  DefinedUnaryOp(op)           -> OfpDefinedOp(op)

//R713
//  ofp-to-ast:  RelOp_EQ()                   -> EQ()
//  ofp-to-ast:  RelOp_NE()                   -> NE()
//  ofp-to-ast:  RelOp_LT()                   -> LT()
//  ofp-to-ast:  RelOp_LE()                   -> LE()
//  ofp-to-ast:  RelOp_GT()                   -> GT()
//  ofp-to-ast:  RelOp_GE()                   -> GE()

//R723
//  ofp-to-ast:  DefinedBinaryOp(op)          -> OfpDefinedOp(op)

//R732
  ofp-to-ast:  AssignmentStmt(label,var,expr,eos("\n")) -> AssignmentStmt(label,var,expr)
  ofp-to-ast:  AssignmentStmt(label,var,expr,eos(str) ) -> AssignmentStmt(label,var,expr) {Comment(str)}

//R1101
  ofp-to-ast:  MainProgram(begin,spec,exec,funcs,end)
                  -> MainProgram(begin,<ofp-fixup-scope>Scope(spec,exec,funcs),end)

//R1102
  ofp-to-ast:  ProgramStmt(label,name,eos("\n")) -> ProgramStmt(label,name)
  ofp-to-ast:  ProgramStmt(label,name,eos(str) ) -> ProgramStmt(label,name) {Comment(str)}

//R1102
  ofp-to-ast:  EndProgramStmt(label,name,eos("\n")) -> EndProgramStmt(label,name)
  ofp-to-ast:  EndProgramStmt(label,name,eos(str) ) -> EndProgramStmt(label,name) {Comment(str)}

//R1104
  ofp-to-ast:  Module(begin,spec,no-module-subprogram-part(),end)
                  -> Module(begin, Scope(spec, ExecPart([]), FuncPart([])), end)
  ofp-to-ast:  Module(begin,spec,ModuleSubprogramPart(contains,l),end)
                  -> Module(begin, Scope(spec, ExecPart([]), FuncPart(l)),  end)

//R1105
  ofp-to-ast:  ModuleStmt(label,name,eos("\n")) -> ModuleStmt(label,name)
  ofp-to-ast:  ModuleStmt(label,name,eos(str) ) -> ModuleStmt(label,name) {Comment(str)}

//R1106
  ofp-to-ast:  EndModuleStmt(label,name,eos("\n")) -> EndModuleStmt(label,name)
  ofp-to-ast:  EndModuleStmt(label,name,eos(str) ) -> EndModuleStmt(label,name) {Comment(str)}

//R1116
  ofp-to-ast:  Submodule(begin,spec,no-module-subprogram-part(),end)
                  -> Submodule(begin, Scope(spec,ExecPart([]),FuncPart([])), end)
  ofp-to-ast:  Submodule(begin,spec,ModuleSubprogramPart(contains,l),end)
                  -> Submodule(begin, Scope(spec,ExecPart([]),FuncPart(l)), end)

//R1117
  ofp-to-ast:  SubmoduleStmt(label,parent,name,eos("\n")) -> SubmoduleStmt(label,parent,name)
  ofp-to-ast:  SubmoduleStmt(label,parent,name,eos(str) ) -> SubmoduleStmt(label,parent,name) {Comment(str)}

//R1119
  ofp-to-ast:  EndSubmoduleStmt(label,name,eos("\n")) -> EndSubmoduleStmt(label,name)
  ofp-to-ast:  EndSubmoduleStmt(label,name,eos(str) ) -> EndSubmoduleStmt(label,name) {Comment(str)}

//R1207
//  ofp-to-ast:  GenericSpec(Name(name))        -> OfpGenericSpec(Name(name))
//  ofp-to-ast:  GenericSpec_AE()               -> OfpGenericSpec(ASSIGNMENT())
//  ofp-to-ast:  GenericSpec(spec)              -> OfpGenericSpec(spec)

//R1211
//ofp-to-ast: ProcedureDeclarationStmt(label,intr,specs,decls,eos)
//              -> OfpProcedureDeclarationStmt(<ofp-label>label,intr,specs,decls)            {Comment(eos)}

//R1227
  ofp-to-ast:  FunctionSubprogram(begin,spec,exec,funcs,end)
                   -> Function(begin,<ofp-fixup-scope>Scope(spec,exec,funcs),end)

//R1228
  ofp-to-ast:  FunctionStmt(label,prefix,name,args,suffix,eos)
                   -> xFunctionStmt(label,prefix,name,args,<ofp-extract-result> suffix,
                                                           <ofp-extract-binding>suffix)
  ofp-to-ast:  no-prefix() -> []

//R1232
  ofp-to-ast:  EndFunctionStmt(label,name,eos("\n")) -> EndFunctionStmt(label,name)
  ofp-to-ast:  EndFunctionStmt(label,name,eos(str) ) -> EndFunctionStmt(label,name) {Comment(str)}

//R1233
  ofp-to-ast:  SubroutineSubprogram(begin,spec,exec,funcs,end)
                   -> Subroutine(begin,<ofp-fixup-scope>Scope(spec,exec,funcs),end)

//R1234
  ofp-to-ast:  SubroutineStmt(label,prefix,name,args,binding,eos("\n"))
                   -> SubroutineStmt(label,prefix,name,args,binding)
  ofp-to-ast:  SubroutineStmt(label,prefix,name,args,binding,eos(str) )
                   -> SubroutineStmt(label,prefix,name,args,binding) {Comment(str)}

//R1236
  ofp-to-ast:  EndSubroutineStmt(label,name,eos("\n")) -> EndSubroutineStmt(label,name)
  ofp-to-ast:  EndSubroutineStmt(label,name,eos(str) ) -> EndSubroutineStmt(label,name) {Comment(str)}


//R1237
  ofp-to-ast:  SeparateModuleSubprogram(begin,spec,exec,funcs,end)
                   -> OfpMpSubprogram(<ofp-extract-name>begin,
                                      <ofp-fixup-scope>Scope(spec,exec,funcs))
