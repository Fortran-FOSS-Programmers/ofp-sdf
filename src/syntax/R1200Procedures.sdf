      
%%%%%%%%%%
%% Fortran ISO/IEC 1539:1991 section 12xx Procedures section
%%%%%%%%%%

%%module languages/fortran/syntax/R1200Procedures
module R1200Procedures

imports
  %% languages/fortran/syntax/FortranLex
  %% languages/fortran/syntax/Fortran90
  FortranLex
  Fortran

exports

sorts

  ActualArg CallStmt ContainsStmt DtioGenericSpec EndFunctionStmt
  EntryStmt ExternalStmt FunctionArg FunctionArgList
  FunctionPar FunctionParList FunctionPrefix FunctionRange
  FunctionReference FunctionStmt FunctionSubprogram GenericSpec
  InterfaceBody IntrinsicStmt ProcedureStmt
  ProcedureName ProcedureNameList ReturnStmt %%TODO SFDummyArgNameList 
  SubroutineRange SubroutineStmt SubroutineSubprogram

  InterfaceBlock                      %% R1201
  InterfaceSpecification              %% R1202
  InterfaceStmt                       %% R1203
  EndInterfaceStmt                    %% R1204
  ImportStmt                          %% R1209
  ImportName
  Prefix                              %% R1225
  PrefixSpec                          %% R1226
  ProcLanguageBindingSpec             %% R1229
  DummyArg                            %% R1235
  EndSubroutineStmt                   %% R1236

  StmtFunctionStmt                    %% R1243

%%F2008
  ProcedureEntityName InterfaceName ProcedureDeclarationStmt ProcDeclList ProcInterface

%%F2008 Experimental
  SubroutineParList

%%TODO SubroutineStmt not used?
%%TODO StmtFunctionStmt ambiguous obsolescant/deleted

context-free syntax

%%R1201
  InterfaceStmt
    InterfaceSpecification*
  EndInterfaceStmt                -> InterfaceBlock          {cons("interface-block")}

%%R1202
    InterfaceBody
  | ProcedureStmt                 -> InterfaceSpecification  {cons("interface-specification")}


%%R1203
  LblDef (
             ('INTERFACE' GenericSpec?)
           | ('ABSTRACT' 'INTERFACE')
         )                                         EOS -> InterfaceStmt     {cons("interface-stmt")}
      
%%R1204
  LblDef 'END' 'INTERFACE' GenericSpec?            EOS -> EndInterfaceStmt  {cons("end-interface-stmt")}

%%R1205
%%       The optional specification-part is ambiguous.  The lack of a specification-part
%%       is detectable from an empty list and None components in the specification-part ATerm.
%%
    (FunctionStmt   SpecificationPart EndFunctionStmt  )
  | (SubroutineStmt SpecificationPart EndSubroutineStmt)  -> InterfaceBody  {cons("interface-body")}

%%REMOVE-F08  LblDef FunctionPrefix FunctionName FunctionInterfaceRange           -> InterfaceBody
%%REMOVE-F08  LblDef 'SUBROUTINE' SubroutineName SubroutineInterfaceRange         -> InterfaceBody

%%REMOVE-F08  FunctionParList      EOS  SubprogramInterfaceBody EndFunctionStmt   -> FunctionInterfaceRange
%%REMOVE-F08  FunctionParList      EOS  EndFunctionStmt                           -> FunctionInterfaceRange

%%REMOVE-F08  SubroutineParList? ProcLanguageBindingSpec?
%%REMOVE-F08                       EOS  SubprogramInterfaceBody EndSubroutineStmt -> SubroutineInterfaceRange
%%REMOVE-F08  SubroutineParList? ProcLanguageBindingSpec?
%%REMOVE-F08                       EOS  EndSubroutineStmt                         -> SubroutineInterfaceRange

%%REMOVE-F08  SpecificationPartConstruct                                -> SubprogramInterfaceBody
%%REMOVE-F08  SubprogramInterfaceBody SpecificationPartConstruct        -> SubprogramInterfaceBody

%%R1206
  LblDef 'MODULE'? 'PROCEDURE' "::"? ProcedureNameList  EOS -> ProcedureStmt  {cons("procedure-stmt")}
  {ProcedureName ","}+                                      -> ProcedureNameList
  Ident                                                     -> ProcedureName

%%R1207
    GenericName
  | ('OPERATOR'   "(" DefinedOperator ")")
  | ('ASSIGNMENT' "(" '='             ")")
  | DtioGenericSpec                         -> GenericSpec      {cons("generic-spec")}

%%R1208
  'READ'  '(' 'FORMATTED'   ')'           -> DtioGenericSpec  {cons("dtio-generic-spec-read-formatted")}
  'READ'  '(' 'UNFORMATTED' ')'           -> DtioGenericSpec  {cons("dtio-generic-spec-read-unformatted")}
  'WRITE' '(' 'FORMATTED'   ')'           -> DtioGenericSpec  {cons("dtio-generic-spec-write-formatted")}
  'WRITE' '(' 'UNFORMATTED' ')'           -> DtioGenericSpec  {cons("dtio-generic-spec-write-unformatted")}

%%R1209
  LblDef 'IMPORT' ( '::'? {ImportName ','}+ )?             EOS -> ImportStmt     {cons("import-stmt")}

  Ident                                                        -> ImportName     {cons("import-name")}

%%R1210
  LblDef 'EXTERNAL' '::'? {ExternalName ','}+              EOS -> ExternalStmt   {cons("external-stmt")}

%%R1211
%%TODO-F08 - add proc-attr-spec
  LblDef 'PROCEDURE' "(" ProcInterface ")" "::"? ProcDeclList  EOS -> ProcedureDeclarationStmt
                                                                        {cons("procedure-declaration-stmt")}

%%R1212
%%TODO-F08 - add declaration-type-spec
  InterfaceName                                             -> ProcInterface

%%R1214
%%TODO-f08 - add proc-pointer-init
  {ProcedureEntityName ","}+                                -> ProcDeclList
  Ident                                                     -> ProcedureEntityName

%%R1215
  Ident                                                     -> InterfaceName

%%R1218
  LblDef 'INTRINSIC' "::"? {IntrinsicProcedureName ","}+   EOS -> IntrinsicStmt  {cons("intrinsic-stmt")}

%%R1219
%%TODO-F08 - procedure-designator
%%TODO-F08 - this is also ambiguous with array reference so perhaps FunctionArgList is not complete
  Name "(" FunctionArgList? ")"                        -> FunctionReference   {cons("function-reference")}

%%R1220
  LblDef 'CALL' SubroutineNameUse                          EOS -> CallStmt   {cons("call-stmt")}
  LblDef 'CALL' SubroutineNameUse "(" {ActualArg ","}* ")" EOS -> CallStmt   {cons("call-stmt")}

%%1221
%%TODO-F08 - procedure-designator

%%1222
%%TODO-F08 - actual-arg-spec
%% [ keyword = ] actual-arg
  FunctionArg                                          -> FunctionArgList
  FunctionArgList "," FunctionArg                      -> FunctionArgList
%%TODO  SectionSubscriptList "," FunctionArg           -> FunctionArgList

%%R1223
%%TODO-F08
  (Name '=')? Expr                                     -> ActualArg
  (Name '=')? '*' LblRef                               -> ActualArg

  Name '=' Expr                                        -> FunctionArg

%%1224
%%TODO-F08 - alt-return-spec

%%1225
  PrefixSpec+                                          -> Prefix       {cons("prefix")}

%%1226
    DeclarationTypeSpec
  | 'ELEMENTAL'
  | 'IMPURE'
  | 'MODULE'
  | 'PURE'
  | 'RECURSIVE'                                        -> PrefixSpec  {cons("prefix-spec")}

%%R1227
  LblDef FunctionPrefix FunctionName FunctionRange     -> FunctionSubprogram  {cons("function-subprogram")}
  FunctionStmt EndFunctionStmt                         -> FunctionSubprogram  {cons("function-subprogram")}
  FunctionParList EOS Body? EndFunctionStmt            -> FunctionRange

%%R1228
%%TODO-F08 - add prefix, dummy-arg-name-list, suffix
  LblDef 'FUNCTION' FunctionName "(" ")"           EOS -> FunctionStmt        {cons("function-stmt")}

%%R1215
  FunctionParList 'result' "(" Name ")" EOS InternalSubProgPart EndFunctionStmt         -> FunctionRange
  FunctionParList 'result' "(" Name ")" EOS Body EndFunctionStmt                        -> FunctionRange
  FunctionParList 'result' "(" Name ")" EOS EndFunctionStmt                             -> FunctionRange
  FunctionParList EOS InternalSubProgPart EndFunctionStmt                               -> FunctionRange

%%R1216
%%R1217
  'RECURSIVE' 'FUNCTION'                       -> FunctionPrefix
  'recursive' TypeSpec 'function'              -> FunctionPrefix
  TypeSpec 'recursive' 'function'              -> FunctionPrefix

%%R1229
  LanguageBindingSpec                          -> ProcLanguageBindingSpec  {cons("proc-language-binding-spec")}

%%R1232
%% endfunction (without spaces) is allowed
  LblDef 'END'                              EOS -> EndFunctionStmt       {cons("end-function-stmt")}
  LblDef 'END' 'FUNCTION' FunctionName?     EOS -> EndFunctionStmt       {cons("end-function-stmt")}

%%R1233
%%TODO  LblDef 'RECURSIVE'? 'SUBROUTINE' SubroutineName SubroutineRange  -> SubroutineSubprogram
%%TODO                                                                         {cons("subroutine-subprogram")}
  SubroutineParList? ProcLanguageBindingSpec?
                       EOS Body? EndSubroutineStmt                       -> SubroutineRange
  SubroutineParList? ProcLanguageBindingSpec?
                       EOS InternalSubProgPart EndSubroutineStmt         -> SubroutineRange
%% split subroutineStmt/subroutineSubprogram needed? (ELI legacy)


  SubroutineStmt Body? EndSubroutineStmt                                 -> SubroutineSubprogram
                                                                               {cons("subroutine-subprogram")}

%%1234
  LblDef Prefix? 'SUBROUTINE' SubroutineName
         (
            "(" {DummyArg ","}* ")"
             ProcLanguageBindingSpec?
         )?                                    EOS -> SubroutineStmt {cons("subroutine-stmt")}
  Ident                                            -> SubroutineName {cons("subroutine-name")}

%%R1235
%%TODO-F08 dummy-arg-name-list
   "(" {DummyArg ","}* ")"                         -> SubroutineParList  {cons("dummy-arg-list")}

%%R1235
   DummyArgName         -> DummyArg
   '*'                  -> DummyArg

%%/* Must be split on semantic grounds, due to the different scopes for the
   LblDef FunctionPrefix Name FunctionParList? EOS       -> FunctionStmt
   TypeSpec? 'function'                                  -> FunctionPrefix

   "(" {FunctionPar ","}* ")" ProcLanguageBindingSpec? -> FunctionParList {cons("function-par-list")}
   DummyArgName                                          -> FunctionPar

%%R1236
  LblDef 'END' ('SUBROUTINE' SubroutineName?)?   EOS -> EndSubroutineStmt   {cons("end-subroutine-stmt")}

%%R1240
%%TODO-F08 add suffix
  LblDef 'ENTRY' EntryName SubroutineParList?
                           ProcLanguageBindingSpec?                       EOS -> EntryStmt
                                                                                     {cons("entry-stmt")}
  LblDef 'ENTRY' EntryName SubroutineParList?
                           ProcLanguageBindingSpec? 'RESULT' "(" Name ")" EOS -> EntryStmt
                                                                                     {cons("entry-stmt")}


%%R1241
  LblDef 'RETURN' Expr?                     EOS -> ReturnStmt          {cons("return-stmt")}

%%R1242
  LblDef 'CONTAINS'                         EOS -> ContainsStmt        {cons("contains-stmt")}

%%R1243
%%          scalar-expr replaced by expr
%%
  LblDef FunctionName '(' {DummyArgName ','}* ')' '=' Expr  EOS -> StmtFunctionStmt  {cons("stmt-function-stmt")}


%%-R1226 
%% statement-functions are obsolete in fortran 95. 
%% The following rule causes ambiguity with assignment statements like
%% FOO(NOARG) = IN2-IN3
%% If you're ok with ambig rules then uncomment the next line.
%% LblDef  Name "(" SFDummyArgNameList? ")" "=" Expr EOS        -> StmtFunctionStmt

%%TODO   {SFDummyArgName ","}+                 -> SFDummyArgNameList
