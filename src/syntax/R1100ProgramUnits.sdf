
%%%%%%%%%%
%% This Fortran grammar is structured according to document ISO/IEC 1539:1991. 
%% Rulenumbers are named R2xx - R12xx as in Annex D of 1539:1991
%% The grammar is adapted from an ELI project grammer, http://eli-project.cvs.sourceforge.net/eli-project
%%
%%%%%%%%%%
%% ISO/IEC 1539:1991 section R2xx Fortran terms and concepts
%%%%%%%%%%

%%module languages/fortran/syntax/Fortran90
module R1100ProgramUnits

%%imports languages/fortran/syntax/FortranLex
%%imports languages/fortran/syntax/R400DataTypes
%%imports languages/fortran/syntax/R500DataDeclarations
%%imports languages/fortran/syntax/R600UseDataObjects
%%imports languages/fortran/syntax/R700Expressions
%%imports languages/fortran/syntax/R800ExecutionControl
%%imports languages/fortran/syntax/R900IOStatements
%%imports languages/fortran/syntax/R1000_IOEditing
%%imports languages/fortran/syntax/R1100ProgramUnits
%%imports languages/fortran/syntax/R1200Procedures

imports FortranLex
%%TODO imports R400DataTypes
imports R500DataDeclarations
%%TODO imports R600UseDataObjects
%%TODO imports R700Expressions
imports R800ExecutionControl
imports R900IOStatements
imports R1000_IOEditing
%%TODO imports R1100ProgramUnits
imports R1200Procedures

exports

sorts
  ArrayName Body
  BodyConstruct CommonBlockName ComponentName DefinedOperator
  ExtendedIntrinsicOp
%%TODO   DummyArgName EndName EntryName
%%TODO ExternalName FunctionName GenericName %%TODO ImpliedDoVariable
%%TODO IntrinsicProcedureName  MainProgram
  MainRange ModuleNature %%TODO Name
%%TODO   NamelistGroupName ObjectName ProgramName ProgramUnit SFDummyArgName
%%TODO SpecificationStmt SubroutineName SubroutineNameUse TypeName

%%TODO - replace with above
  IntrinsicOperator
  UseStmt UseName
  BlockDataStmt EndBlockDataStmt BlockDataName
  
  Program                             %% R201
  ProgramUnit                         %% R202
  ExternalSubprogram                  %% R203
  SpecificationPart                   %% R204
  ImplicitPart                        %% R205
  ImplicitPartStmt                    %% R206
  DeclarationConstruct                %% R207
  ExecutionPart                       %% R208
  ExecutionPartConstruct              %% R209
  InternalSubprogramPart              %% R210
  InternalSubprogram                  %% R211
  OtherSpecificationStmt              %% R212
  ExecutableConstruct                 %% R213
  ActionStmt                          %% R214
  Keyword                             %% R215

  MainProgram                         %% R1101
  ProgramStmt                         %% R1102
  EndProgramStmt                      %% R1103

  Module                              %% R1104
  ModuleStmt                          %% R1105
  EndModuleStmt                       %% R1106
  ModuleSubprogramPart                %% R1107
  ModuleSubprogram                    %% R1108

  Rename                              %% R1111
  Only                                %% R1112
  Submodule                           %% R1116
  SubmoduleStmt                       %% R1117
  ParentIdentifier                    %% R1118
  SubmoduleName
  AncestorModuleName
  ParentSubmoduleName
  EndSubmoduleStmt                    %% R1119
  BlockData                           %% R1120

context-free start-symbols 
  Program

context-free syntax

%%R201 JD: the optional startcommentblock is needed to parse comment lines in 1st lines of a file.
%% original: ExecutableProgram ProgramUnit -> ExecutableProgram

%%R201
  StartCommentBlock?  ProgramUnit+             -> Program          {cons("program")}

%%R202
    MainProgram
  | ExternalSubprogram
  | Module
  | Submodule
  | BlockData                                  -> ProgramUnit      {cons("program-unit")}

%%R203
    FunctionSubprogram
  | SubroutineSubprogram                       -> ExternalSubprogram  {cons("external-subprogram")}
  
%%R204
  UseStmt*
  ImportStmt*
  ImplicitPart?
  DeclarationConstruct*                        -> SpecificationPart   {cons("specification-part")}

%%R205
%%TODO-F2008 implement implicit-part by ignoring order and fix order in rewrite
  ImplicitPartStmt* ImplicitStmt               -> ImplicitPart  {cons("implicit-part")}

%%R206
    ImplicitStmt
  | ParameterStmt
  | FormatStmt
  | EntryStmt                                  -> ImplicitPartStmt      {cons("implicit-part-stmt")}

%%R207
    DerivedTypeDef
  | EntryStmt
  | EnumDef
  | FormatStmt
  | InterfaceBlock
  | ParameterStmt
  | ProcedureDeclarationStmt
  | OtherSpecificationStmt
  | TypeDeclarationStmt
  | StmtFunctionStmt                           -> DeclarationConstruct  {cons("declaration-construct")}

%%R208
  ExecutableConstruct ExecutionPartConstruct*  -> ExecutionPart

%%R209
    ExecutableConstruct
  | FormatStmt
  | EntryStmt
  | DataStmt                                   -> ExecutionPartConstruct  {cons("execution-part-construct")}

%%R210
  ContainsStmt InternalSubprogram*             -> InternalSubprogramPart  {cons("internal-subprogram-part")}

%%R211
    FunctionSubprogram
  | SubroutineSubprogram                       -> InternalSubprogram      {cons("internal-subprogram")}

%%R212
    AccessStmt
  | AllocatableStmt
  | AsynchronousStmt
  | BindStmt
  | CodimensionStmt
  | CommonStmt
  | DataStmt
  | DimensionStmt
  | EquivalenceStmt
  | ExternalStmt
  | IntentStmt
  | IntrinsicStmt
  | NamelistStmt
  | OptionalStmt
  | PointerStmt
  | ProtectedStmt
  | SaveStmt
  | TargetStmt
  | VolatileStmt
  | ValueStmt                                  -> OtherSpecificationStmt  {cons("other-specification-stmt")}

%%R213
%%       do-construct is problematic because a labeled statement
%%          may terminate it not necessarily an end-do-stmt.
%%          Replace by do-stmt and end-do-stmt and resolve
%%          the construct end at a latter stage.
%%
    ActionStmt
  | AssociateConstruct
  | BlockConstruct
  | CaseConstruct
  | CriticalConstruct
%%AMBIGUOUS | DoConstruct
  | DoStmt
  | EndDoStmt
  | ForallConstruct
  | IfConstruct
  | SelectTypeConstruct
  | WhereConstruct
                                               -> ExecutableConstruct  {cons("executable-construct")}

%%R214
%%TODO-REMOVE  AssignStmt
%%TODO-REMOVE  AssignedGotoStmt
%%TODO-REMOVE  PauseStmt
%%TODO-REMOVE  StmtFunctionStmt  %% see R1226 comment
%%TODO-REMOVE  AllstopStmt
    AllocateStmt
  | AssignmentStmt
  | BackspaceStmt
  | CallStmt
  | CloseStmt
  | ContinueStmt
  | CycleStmt
  | DeallocateStmt
%%TODO-F08  | EndFunctionStmt
%%TODO-F08  | EndMpSubprogramStmt
%%TODO-F08  | EndProgramStmt
%%TODO-F08  | EndSubroutineStmt
  | EndfileStmt
%%TODO-F08  | ErrorStopStmt
  | ExitStmt
  | FlushStmt
%%TODO-F08  | ForallStmt
  | GotoStmt
  | IfStmt
  | InquireStmt
%%TODO-F08  | LockStmt
  | NullifyStmt
  | OpenStmt
  | PointerAssignmentStmt
  | PrintStmt
  | ReadStmt
  | ReturnStmt
  | RewindStmt
  | StopStmt
%%TODO-F08  | SyncAllStmt
%%TODO-F08  | SyncImagesStmt
%%TODO-F08  | SyncMemoryStmt
%%TODO-F08  | UnlockStmt
  | WaitStmt
  | WhereStmt
  | WriteStmt
  | ArithmeticIfStmt
  | ComputedGotoStmt                   -> ActionStmt  {cons("action-stmt")}

%%215
  Name                                 -> Keyword     {cons("keyword")}

%%R215
%%TODO-REMOVE  Ident '='                     -> KeywordEqual          {cons("keyword-equal")}
%%TODO-REMOVE  KeywordEqual?                 -> OptKeywordEqual

%%R1101
%%TODO-F08 try F08 structure
  ProgramStmt? MainRange                       -> MainProgram      {cons("main-program")}
  BodyConstruct+         EndProgramStmt        -> MainRange        {cons("main-range")}
  InternalSubprogramPart EndProgramStmt        -> MainRange        {cons("main-range")}
  EndProgramStmt                               -> MainRange        {cons("main-range")}

  SpecificationPart                            -> BodyConstruct
  ExecutableConstruct                          -> BodyConstruct
  BodyConstruct+                               -> Body

%%R1102
  LblDef 'PROGRAM'       ProgramName       EOS -> ProgramStmt      {cons("program-stmt")}

%%R1103
  LblDef 'END' ('PROGRAM' ProgramName?)?   EOS -> EndProgramStmt   {cons("end-program-stmt")}

%%R1104
  ModuleStmt
    SpecificationPart
    ModuleSubprogramPart?
  EndModuleStmt                                -> Module           {cons("module")}

%%R1105
  LblDef 'MODULE' ModuleName               EOS -> ModuleStmt       {cons("module-stmt")}

%%R1106
  LblDef 'END' ('MODULE' ModuleName?)?     EOS -> EndModuleStmt    {cons("end-module-stmt")}

%%TODO-DELETE  SpecificationPartConstruct                   -> ModuleBody
%%TODO-DELETE  ModuleSubprogramPartConstruct                -> ModuleBody
%%TODO-DELETE  ModuleBody SpecificationPartConstruct        -> ModuleBody
%%TODO-DELETE  ModuleBody ModuleSubprogramPartConstruct     -> ModuleBody

%%R1107
  ContainsStmt ModuleSubprogram*               -> ModuleSubprogramPart  {const("module-subprogram-part")}

%%R1108
    FunctionSubprogram
  | SubroutineSubprogram
  | SeparateModuleSubprogram                   -> ModuleSubprogram  {cons("module-subprogram")}

%%R1109
  LblDef 'USE' (("," ModuleNature)? "::")? ModuleName
     (
           (","            {Rename ","}*)
        |  ("," 'ONLY' ":" {Only   ","}*)
     )?
                                           EOS -> UseStmt {cons("use-stmt")}

%%R1110
    'INTRINSIC'
  | 'NON_INTRINSIC'                            -> ModuleNature  {cons("module-nature")}


%%1111
%%TODO-F08 - add OPERATORs
  Ident "=>" UseName                           -> Rename

  Ident                                        -> UseName

%%R1112
%%TODO-F08 - add generic-spec, rename and only-use-name
  UseName                                    -> Only  {cons("only")}

%%R1116
%%       The optional specification-part is ambiguous.  The lack of a specification-part
%%       is detectable from an empty list and None components in the specification-part ATerm.
%%
  SubmoduleStmt
    SpecificationPart
    ModuleSubprogramPart?
  EndSubmoduleStmt                               -> Submodule         {cons("submodule")}

%%R1117
  LblDef 'SUBMODULE' '(' ParentIdentifier ')'
         SubmoduleName                       EOS -> SubmoduleStmt     {cons("submodule-stmt")}

%%R1118
  AncestorModuleName (':' ParentSubmoduleName)?  -> ParentIdentifier  {cons("parent-identifier")}

  Ident                                          -> SubmoduleName        {cons("submodule-name")}
  Ident                                          -> AncestorModuleName   {cons("ancestor-module-name")}
  Ident                                          -> ParentSubmoduleName  {cons("parent-submodule-name")}

%%R1119
  LblDef 'END' ('SUBMODULE' SubmoduleName?)? EOS -> EndSubmoduleStmt  {cons("end-submodule-stmt")}

%%R1120
%%       The optional specification-part is ambiguous.  The lack of a specification-part
%%       is detectable from an empty list and None components in the specification-part ATerm.
%%
  BlockDataStmt
    SpecificationPart
  EndBlockDataStmt                               -> BlockData         {cons("block-data")}

%%R1121
  LblDef 'BLOCK' 'DATA' BlockDataName?       EOS -> BlockDataStmt     {cons("block-data-stmt")}

%%R1122
  LblDef 'END' 'BLOCK' 'DATA' BlockDataName? EOS -> EndBlockDataStmt  {cons("end-block-data-stmt")}
  LblDef 'END'                               EOS -> EndBlockDataStmt  {cons("end-block-data-stmt")}

  Ident -> BlockDataName

%%TODO-DELETE  BlockDataBodyConstruct+ -> BlockDataBody
%%TODO-DELETE  SpecificationPartConstruct -> BlockDataBodyConstruct

%%R310
    '**'                                                       %% power-op
  | ('*' | '/')                                                %% mult-op
  | ('+' | '-')                                                %% add-op
  | '//'                                                       %% concat-op
  | ( '.EQ.' | '.NE.' | '.LT.' | '.LE.' | '.GT.' | '.GE.' |
      '=='   | '/='   | '<'    | '<='   | '>'    | '>=' )      %% rel-op
  | '.NOT.'                                                    %% not-op
  | '.AND.'                                                    %% and-op
  | '.OR.'                                                     %% or-op
  | ('.EQV.' | '.NEQV.')                                       %% equiv-op
                                -> IntrinsicOperator     {cons("intrinsic-operator")}

%%R310
    DefinedUnaryOp
  | DefinedBinaryOp
  | ExtendedIntrinsicOp         -> DefinedOperator       {cons("defined-operator")}

%%R312
  IntrinsicOperator             -> ExtendedIntrinsicOp
